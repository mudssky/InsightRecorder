## 改动目标

- 文件名：同步后保持“源文件原名”；仅当目标目录存在同名文件时才进行重命名（如追加序号）。
- 目录结构：不再按源设备的子目录结构展开，直接放入“对应的目标目录”。
- 父目录名：按提供的模板生成父级目录名（使用设备级 `folderTemplate`，无则使用全局模板），当前行为是用模板生成文件名，需要改为生成“目录名”。

## 关键行为设计

- 目标父目录构造：`destDir = path.join(targetBase, renderTemplate(folderTemplate, ctx))`，其中 `ctx` 包含 `{device, date, time}` 等常用占位变量。
- 目标文件名：`basename = path.basename(srcFile)`（保持原名）。
- 重名策略：当 `path.join(destDir, basename)` 已存在时，采用递增后缀：`name (1).ext`, `name (2).ext`...
- 跳过逻辑调整：不再因为“索引存在或目标存在”而跳过；存在则重命名并复制。
- 索引记录：复制成功后仍写入 `exportIndexStore`，用于历史查询，但不参与跳过判断。

## 具体代码改动点

- `src/main/ipc/export.ts`
  1. 设备/全局配置提取：保留 `exts/minSize/maxSize`；将 `dev.folderTemplate`（优先）或全局模板用于“父目录名”。不再用模板生成文件名。
  2. 新增 `renderTemplate(template, deviceId, srcFile, dateCtx)`：返回安全的目录名字符串（处理非法字符）。
  3. 新增 `resolveConflictName(destDir, basename)`：存在则递增后缀，返回唯一文件名。
  4. 修改导出循环：
     - 计算 `destDir` 并 `ensureDir(destDir)`。
     - `basename = path.basename(file)`；`finalName = resolveConflictName(destDir, basename)`。
     - 执行复制到 `path.join(destDir, finalName)`；发送 `stage: 'copied'` 事件，附带最终路径。
     - 若 `deleteSourceAfterSync` 为真，删除源文件。
  5. 删除/改写现有 `buildTargetPath`：改为仅返回目录路径，或重命名为 `buildTargetDir`；相应调用处更新。

## 模板占位约定

- `{device}`：设备 ID 的安全版本（非字母数字替换为 `_`）。
- `{date:YYYYMMDD}`、`{time:HHmmss}`：基于源文件的 `mtimeMs`。
- 可保留 `{title}`，但仅用于目录名时建议忽略，避免过深目录。若保留，将从 `srcFile` 的无扩展名提取。

## 边界与兼容

- 若无模板：默认父目录名为 `{device}`。
- Windows 路径安全：过滤 `<>:"/\|?*` 等非法字符；长度超限时截断。
- 性能：重名检测采用最多 100 次递增保护，极端情况下回退到时间戳后缀。

## 验证流程

- 运行 `pnpm qa`（类型检查/ESLint/格式化）。
- 运行 `pnpm run build`，确认构建产物尺寸与日志正常。
- 运行 `pnpm run start`，用两个同名文件验证：首次复制保持原名；第二次复制生成 `(1)` 后缀；父目录名按模板渲染。
- 观察 `export:progress` 事件：成功时包含最终目标路径；无 `skip` 事件。

## 交付与回滚

- 改动仅限 `src/main/ipc/export.ts`；不修改数据库结构。
- 保留原 `exportIndexStore` 写入，便于历史检索；如需后续去重策略，可扩展为内容哈希比对。

请确认以上方案，确认后我将提交具体代码改动并完成验证。
